<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[android中actionBar使用]]></title>
      <url>/blogs/actionBar/</url>
      <content type="html"><![CDATA[<p>Action Bar是一种新増的导航栏功能，在Android 3.0之后加入到系统的API当中，它标识了用户当前操作界面的位置，并提供了额外的用户动作、界面导航等功能。使用ActionBar的好处是，它可以给提供一种全局统一的UI界面，使得用户在使用任何一款软件时都懂得该如何操作，并且ActionBar还可以自动适应各种不同大小的屏幕<br><a id="more"></a></p>
<the rest="" of="" contents="" |="" 余下全文="">


<h3 id="1、设置actionBar"><a href="#1、设置actionBar" class="headerlink" title="1、设置actionBar"></a>1、设置actionBar</h3><p>(1)代码中<br>    ①没有使用v7兼容库，ActionBar actionBar = getActionBar();<br>    ②使用v7兼容库，ActionBar actionBar = getSupportActionBar();<br>    actionBar.hide() 隐藏actionBar<br>    actionBar.show() 显示actionBar<br> (2)xml中<br>    ①隐藏actionBar<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;</div><div class="line">②使用actionBar</div></pre></td></tr></table></figure></p>
<pre><code>&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt;
</code></pre><h3 id="2、设置全屏，即隐藏导航栏"><a href="#2、设置全屏，即隐藏导航栏" class="headerlink" title="2、设置全屏，即隐藏导航栏"></a>2、设置全屏，即隐藏导航栏</h3><p>(1)代码中<br>    getWindow().setFlag(WindowManager.LayoutParams.FLAG_FULLSCREEN,<br>                WindowManager.LayoutParams.FLAG_FULLSCREEN);<br>(2)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt;</div></pre></td></tr></table></figure></p>
<h3 id="3、设置translucent-system-bar-即设置导航栏的外观，4-4之后才支持-不能设置全屏"><a href="#3、设置translucent-system-bar-即设置导航栏的外观，4-4之后才支持-不能设置全屏" class="headerlink" title="3、设置translucent system bar,即设置导航栏的外观，4.4之后才支持,不能设置全屏"></a>3、设置translucent system bar,即设置导航栏的外观，4.4之后才支持,不能设置全屏</h3><p>(1)v19-v20<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt;</div><div class="line">       &lt;item name=&quot;android:windowTranslucentNavigation&quot;&gt;true&lt;/item&gt;</div></pre></td></tr></table></figure></p>
<p> (2)v21以上<br>    <item name="android:windowTranslucentStatus">false</item><br>        <item name="android:windowTranslucentNavigation">true</item><br>        <!--Android 5.x开始需要把颜色设置透明，否则导航栏会呈现系统默认的浅灰色--><br>        <item name="android:statusBarColor">@android:color/transparent</item><br>在布局根元素设置颜色，并且设置android:fitsSystemWindows=”true”，不会让系统导航栏和我们app的UI重叠</p>
</the>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[android中常见的几种布局优化方式]]></title>
      <url>/blogs/layout/</url>
      <content type="html"><![CDATA[<p>本文主要讲解android中常见的几种布局优化方式，写Android的xml布局时,用好 include、ViewStub、merge 这三个标签，可以是我们的xml更加简洁、高效,希望通过自己的浅显理解能对初学者有所帮助。<br><a id="more"></a></p>
<the rest="" of="" contents="" |="" 余下全文="">


<h3 id="1、减少布局层级"><a href="#1、减少布局层级" class="headerlink" title="1、减少布局层级"></a>1、减少布局层级</h3><p>布局中层级太多，一般是使用多个LinearLayout嵌套，导致层级过多，这个时候可以使用RelativeLayout代替LinearLayout，降低层级次数，因为RelativeLayout可定制功能丰富，比较简单，根据实际情况修改即可.</p>
<h3 id="2、include标签"><a href="#2、include标签" class="headerlink" title="2、include标签"></a>2、include标签</h3><p>使用include标签，一些通用的布局，比如标题栏、按钮等，可以使用写到单独的布局中，使用include标签引用，既方便了以后修改，也增加了灵活性.<br>注意点:使用include最常见的问题就是findViewById时候出现NullPointerException,这个问题出现的前提是在布局中设置了id，被 include 进来的布局的根元素也设置了id,那么这时使用被 include 进来的根元素id进行 findViewById 就会出现NullPointerException，即设置include标签的id会取代布局的根元素的id。</p>
<h3 id="3、merge标签"><a href="#3、merge标签" class="headerlink" title="3、merge标签"></a>3、merge标签</h3><p>使用”merge”标签减少层级,它可以删减多余的层级，优化UI，merge 原理就是在解析xml时候，如果是merge 标签，那么直接将其中的子元素添加到merge 标签parent中，这样就保证了不会引入额外的层级</p>
<h3 id="4、ViewStub标签"><a href="#4、ViewStub标签" class="headerlink" title="4、ViewStub标签"></a>4、ViewStub标签</h3><p>使用ViewStub提高布局性能，在Android开发中,View是我们必须要接触的用来展示的技术.通常情况下随着View视图的越来越复杂,整体布局的性能也会随之下降.这里介绍一个在某些场景下提升布局性能的View,它就是ViewStub。<br>(1)ViewStub简介<br>    ①ViewStub是View的子类  ②它不可见,大小为0  ③用来延迟加载布局资源,保证性能,在ViewStub布局可显示之前，系统不会消耗资源去实例化里面的布局，可以节省系统资源消耗<br>(2)设置 ViewStub 中延时加载的布局有两种方式<br>    ①在xml中使用 android:layout 属性来设置<br>    ②在代码中使用 ViewStub.setLayoutResource(res); 来设置<br>(3)使ViewStub中布局显示出来也有两种方法<br>    ViewStub viewStub = (ViewStub) findViewById(R.id.viewstub)<br>    if(viewStub!=null){//未加载<br>        ①调用 viewStub.setVisibility(View.VISIBLE);<br>        ②调用 viewStub.inflate();<br>    }else{//已加载</p>
<pre><code>}
①和②两种方法都可以让布局显示
</code></pre><p>(4)关于ViewStub的事<br>   ①除了inflate方法外,我们还可以调用setVisibility()方法加载布局文件<br>   ②一旦加载布局完成后,ViewStub会从当前布局层级中删除<br>   ③android:id指定ViewStub ID,用于查找ViewStub进行延迟加载<br>   ④android:layout延迟加载布局的资源id<br>   ⑤android:inflatedId加载的布局被重写的id,这里为RelativeLayout的id<br>(5)ViewStub的不足和优点<br>   ①ViewStub不支持merge标签.<br>   ②ViewStub对include标签支持良好的</p>
</the>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello]]></title>
      <url>/blogs/hello/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<a id="more"></a>
<the rest="" of="" contents="" |="" 余下全文="">

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
</the>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[TCP和Http的区别]]></title>
      <url>/blogs/tcp_with_http/</url>
      <content type="html"><![CDATA[<p>相信不少初学手机联网开发的朋友都想知道Http与Socket连接究竟有什么区别，希望通过自己的浅显理解能对初学者有所帮助。<br><a id="more"></a></p>
<the rest="" of="" contents="" |="" 余下全文="">


<h3 id="1、TCP连接"><a href="#1、TCP连接" class="headerlink" title="1、TCP连接"></a>1、TCP连接</h3><p>手机能够使用联网功能是因为手机底层实现了TCP/IP协议，可以使手机终端通过无线网络建立TCP连接。TCP协议可以对上层网络提供接口，使上层网络数据的传输建立在“无差别”的网络之上。<br>建立起一个TCP连接需要经过“三次握手”：<br>第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；<br>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。<br>握 手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连 接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”（过程就不细写 了，就是服务器和客户端交互，最终确定断开）</p>
<h3 id="2、HTTP连接"><a href="#2、HTTP连接" class="headerlink" title="2、HTTP连接"></a>2、HTTP连接</h3><p>HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。<br>HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。<br>1）在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。</p>
<p>2）在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。</p>
<p>由 于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的 做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客 户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。</p>
<h3 id="3、SOCKET原理"><a href="#3、SOCKET原理" class="headerlink" title="3、SOCKET原理"></a>3、SOCKET原理</h3><p>3.1套接字（socket）概念<br>套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。<br>应 用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协 议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以 和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p>
<p>3.2 建立socket连接</p>
<p>建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。<br>套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。<br>服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。<br>客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。<br>连 接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户 端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</p>
<h3 id="4、SOCKET连接与TCP连接"><a href="#4、SOCKET连接与TCP连接" class="headerlink" title="4、SOCKET连接与TCP连接"></a>4、SOCKET连接与TCP连接</h3><p>创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。</p>
<h3 id="5、Socket连接与HTTP连接"><a href="#5、Socket连接与HTTP连接" class="headerlink" title="5、Socket连接与HTTP连接"></a>5、Socket连接与HTTP连接</h3><p>由 于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用 中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导 致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。<br>而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。<br>很 多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给 客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以 保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。</p>
</the>]]></content>
      
        
    </entry>
    
  
  
</search>
